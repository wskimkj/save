<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>공동 부부 가계부</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; margin: 12px 0; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; }
    input[type="number"] { width: 140px; }
    input[type="text"] { width: 160px; }
    select { padding: 6px; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button.primary { border-color: #333; }
    button:disabled { cursor: not-allowed; opacity: 0.5; }
    .muted { color: #666; font-size: 12px; }
    .tabs button { border: none; border-bottom: 2px solid transparent; border-radius: 0; padding: 10px 8px; }
    .tabs button.active { border-bottom-color: #333; font-weight: 600; }
    .hidden { display: none; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #ddd; border-radius:999px; font-size:12px; color:#555; }
    pre { white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>공동 부부 가계부</h1>

  <div class="row">
    <label>월(month_key):
      <input id="monthKey" value="2025.08" placeholder="YYYY.MM" />
    </label>
    <span class="muted">예: 2025.08</span>

    <label>입력 대상(구분):
      <select id="owner">
        <option value="공통" selected>공통</option>
        <option value="돌프">돌프</option>
        <option value="천사">천사</option>
      </select>
    </label>
    <span class="pill">Monthly Edit는 선택한 대상에 저장</span>
  </div>

  <div class="tabs row" style="margin-top:12px">
    <button data-tab="dashboard" class="active">Dashboard</button>
    <button data-tab="monthly">Monthly Edit</button>
    <button data-tab="upload">Bulk Upload</button>
    <button data-tab="db">DB (Monthly)</button>
  </div>

  <!-- Dashboard -->
  <section id="tab-dashboard" class="card">
    <h2>Dashboard</h2>
    <div class="row">
      <button id="btnRefresh" class="primary">DB에서 새로고침</button>
      <span id="status" class="muted"></span>
    </div>

    <div class="row" style="margin-top:12px">
      <div class="card" style="flex:1; min-width:220px">
        <div class="muted">총지출</div><div id="kpiSpend" style="font-size:24px">-</div>
      </div>
      <div class="card" style="flex:1; min-width:220px">
        <div class="muted">총저축</div><div id="kpiSave" style="font-size:24px">-</div>
      </div>
      <div class="card" style="flex:1; min-width:220px">
        <div class="muted">총수입</div><div id="kpiIncome" style="font-size:24px">-</div>
      </div>
    </div>

    <p class="muted">
      ※ KPI/차트는 Power Automate(HTTP) → Office Script(API)로 DB에서 읽어옵니다.
    </p>
  </section>

  <!-- Monthly Edit -->
  <section id="tab-monthly" class="card hidden">
    <h2>Monthly Edit (기록 UI)</h2>
    <p class="muted">
      카테고리명은 엑셀 DB 시트 단어표(L~U)의 <b>상세항목</b>과 동일해야 분류가 자동 반영됩니다.
      값 수정 후 <b>“DB 반영(커밋)”</b>을 누르면 <b>선택한 월 + 입력 대상(구분)</b> 기준으로 DB를 교체합니다.
      (빈칸은 변경 없음)
    </p>

    <table id="catTable">
      <thead>
        <tr><th>Category</th><th>Amount</th></tr>
      </thead>
      <tbody></tbody>
    </table>

    <div class="row" style="margin-top:12px">
      <button id="btnReload">DB에서 불러오기</button>
      <button id="btnCommit" class="primary">DB 반영(커밋)</button>
      <span id="monthlyMsg" class="muted"></span>
    </div>
  </section>

  <!-- Bulk Upload -->
  <section id="tab-upload" class="card hidden">
    <h2>Bulk Upload</h2>
    <p class="muted">
      템플릿(CSV)을 내려받아 작성 후 업로드하세요. 헤더는
      <b>month_key,owner,category,amount</b> 입니다.
      (분류는 엑셀 DB의 L~U 룰이 자동 적용되도록 <b>category를 단어표의 상세항목과 동일</b>하게 작성)
    </p>

    <div class="row">
      <button id="btnDownloadTemplate">템플릿 다운로드(CSV)</button>
      <span class="muted">xlsx까지 하려면 브라우저 파서 라이브러리(예: SheetJS)가 필요해요.</span>
    </div>

    <div class="row" style="margin-top:12px">
      <input type="file" id="fileInput" accept=".csv" />
      <button id="btnPreview">미리보기</button>
      <button id="btnApplyUpload" class="primary">업로드 반영(월+구분 단위 교체)</button>
      <span id="uploadMsg" class="muted"></span>
    </div>

    <pre id="preview" style="background:#fafafa; padding:12px; border-radius:10px; overflow:auto; max-height:260px"></pre>
  </section>

  <!-- DB (Monthly) - 기록 시트처럼 보기 -->
  <section id="tab-db" class="card hidden">
    <h2>DB (Monthly) — 기록 시트처럼</h2>
    <p class="muted">
      DB에 저장된 값을 <b>기록 시트처럼 월/구분/카테고리별</b>로 보고 수정합니다.
      <b>source=ALL</b>은 <b>ui_monthly + upload_monthly 합산 조회용</b>이라 저장(업데이트)은 비활성화됩니다.
    </p>

    <div class="row">
      <label>month_key:
        <input id="dbMonthKey" placeholder="YYYY.MM" />
      </label>

      <label>owner:
        <select id="dbOwner">
          <option value="공통" selected>공통</option>
          <option value="돌프">돌프</option>
          <option value="천사">천사</option>
        </select>
      </label>

      <label>source:
        <select id="dbSource">
          <option value="ui_monthly" selected>ui_monthly (웹 입력)</option>
          <option value="upload_monthly">upload_monthly (벌크 업로드)</option>
          <option value="ALL">ALL (합산 조회 전용)</option>
        </select>
      </label>

      <button id="btnDbReload">DB에서 불러오기</button>
      <button id="btnDbCommit" class="primary">DB에 저장(월 교체)</button>
      <span id="dbMonthlyMsg" class="muted"></span>
    </div>

    <table id="dbCatTable" style="margin-top:12px">
      <thead>
        <tr><th>Category</th><th>Amount</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

<script>
  // ================== 설정 ==================
  // ✅ Power Automate의 "When an HTTP request is received" 트리거에서 생성되는 URL을 여기에 붙여넣으세요.
  // 예) https://prod-xx.westus.logic.azure.com:443/workflows/.../triggers/manual/paths/invoke?api-version=...
  const API_URL = ""; // TODO: 여기에 붙여넣기

  // ✅ 카테고리명은 "엑셀 DB 시트 L~U 단어표(상세항목)"과 문자열이 동일해야
  //    소분류/대분류(VLOOKUP)가 그대로 자동 반영됩니다.
  const CATEGORIES = [
    "식재료","외식","배달","중식","카페/간식",
    "쇼핑","미용","구독","생활편의",
    "여행","문화생활","운동",
    "보험","병원·약국","미용시술","건강식품",
    "회비","경조/선물","친목","기부",
    "기타",
    "주거/통신","교통","공과금",
    "저축","투자","부채상환",
    "월급","기타수입","금융이자","주식매도"
  ];

  // ================== 탭 전환 ==================
  document.querySelectorAll(".tabs button").forEach(btn => {
    btn.addEventListener("click", () => {
      document.querySelectorAll(".tabs button").forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      const tab = btn.dataset.tab;
      document.querySelectorAll("section[id^='tab-']").forEach(s => s.classList.add("hidden"));
      document.getElementById(`tab-${tab}`).classList.remove("hidden");
    });
  });

  // ================== API helper (단일 엔드포인트) ==================
  async function callApi(payload) {
    if (!API_URL) throw new Error("API_URL이 비어있어요. Power Automate URL을 붙여넣어주세요.");
    const res = await fetch(API_URL, {
      method: "POST",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });
    if (!res.ok) throw new Error(await res.text());
    return res.json().catch(() => ({}));
  }

  // ================== 공통: 카테고리 테이블 렌더 ==================
  const monthlyTbody = document.querySelector("#catTable tbody");
  const dbMonthlyTbody = document.querySelector("#dbCatTable tbody");

  const state = {
    monthly: Object.fromEntries(CATEGORIES.map(c => [c, ""])),
    dbMonthly: Object.fromEntries(CATEGORIES.map(c => [c, ""])),
  };

  function renderCategoryTable(tbody, model) {
    tbody.innerHTML = "";
    CATEGORIES.forEach(cat => {
      const tr = document.createElement("tr");
      const td1 = document.createElement("td"); td1.textContent = cat;
      const td2 = document.createElement("td");
      const inp = document.createElement("input");
      inp.type = "number";
      inp.placeholder = "금액";
      inp.value = model[cat] ?? "";
      inp.addEventListener("input", () => model[cat] = inp.value);
      td2.appendChild(inp);
      tr.append(td1, td2);
      tbody.appendChild(tr);
    });
  }

  renderCategoryTable(monthlyTbody, state.monthly);
  renderCategoryTable(dbMonthlyTbody, state.dbMonthly);

  // ================== Monthly Edit ==================
  document.getElementById("btnReload").addEventListener("click", async () => {
    const month_key = document.getElementById("monthKey").value.trim();
    const owner = document.getElementById("owner").value;
    const msg = document.getElementById("monthlyMsg");
    msg.textContent = "불러오는 중...";
    try {
      const data = await callApi({
        action: "readMonthly",
        month_key,
        owner,
        source: "ui_monthly"
      });

      CATEGORIES.forEach(c => state.monthly[c] = "");
      (data.items || []).forEach(it => {
        if (it && it.category && CATEGORIES.includes(it.category)) {
          state.monthly[it.category] = (it.amount ?? "") + "";
        }
      });

      renderCategoryTable(monthlyTbody, state.monthly);
      msg.textContent = `DB 기준(ui_monthly) 갱신 완료 (${month_key} / ${owner})`;
    } catch (e) {
      msg.textContent = "실패: " + e.message;
    }
  });

  document.getElementById("btnCommit").addEventListener("click", async () => {
    const month_key = document.getElementById("monthKey").value.trim();
    const owner = document.getElementById("owner").value;
    const msg = document.getElementById("monthlyMsg");
    msg.textContent = "DB 반영 중...";
    try {
      const items = Object.entries(state.monthly)
        .filter(([_, v]) => v !== "" && v !== null && v !== undefined)
        .map(([category, v]) => ({ category, amount: Number(v) }));

      await callApi({
        action: "commitMonthly",
        month_key,
        owner,
        source: "ui_monthly",
        items
      });

      msg.textContent = `DB 반영 완료 (${month_key} / ${owner})`;
    } catch (e) {
      msg.textContent = "실패: " + e.message;
    }
  });

  // ================== Dashboard ==================
  document.getElementById("btnRefresh").addEventListener("click", async () => {
    const month_key = document.getElementById("monthKey").value.trim();
    const owner = document.getElementById("owner").value;
    const status = document.getElementById("status");
    status.textContent = "불러오는 중...";
    try {
      const data = await callApi({ action: "kpi", month_key, owner });
      document.getElementById("kpiSpend").textContent = data.spend ?? "-";
      document.getElementById("kpiSave").textContent = data.save ?? "-";
      document.getElementById("kpiIncome").textContent = data.income ?? "-";
      status.textContent = "완료";
    } catch (e) {
      status.textContent = "실패: " + e.message;
    }
  });

  // ================== Bulk Upload ==================
  document.getElementById("btnDownloadTemplate").addEventListener("click", () => {
    const header = "month_key,owner,category,amount\n";
    const sample = [
      "2025.08,공통,식재료,320000",
      "2025.08,돌프,외식,180000",
      "2025.08,천사,카페/간식,90000"
    ].join("\n");
    const csv = header + sample + "\n";

    const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "monthly_upload_template.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  let uploadItems = [];

  function parseCsv(text) {
    const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
    if (lines.length < 2) throw new Error("CSV에 데이터가 없어요.");

    const headers = lines[0].split(",").map(s => s.trim());
    const idxMonth = headers.indexOf("month_key");
    const idxOwner = headers.indexOf("owner");
    const idxCat = headers.indexOf("category");
    const idxAmt = headers.indexOf("amount");
    if (idxMonth < 0 || idxOwner < 0 || idxCat < 0 || idxAmt < 0) {
      throw new Error("CSV 헤더는 month_key,owner,category,amount 여야 해요.");
    }

    return lines.slice(1).map((line, i) => {
      const cols = line.split(",").map(s => s.trim());
      const row = {
        month_key: cols[idxMonth],
        owner: cols[idxOwner],
        category: cols[idxCat],
        amount: Number(cols[idxAmt])
      };
      if (!row.month_key || !row.owner || !row.category || Number.isNaN(row.amount)) {
        throw new Error(`CSV ${i+2}행 형식이 이상해요: ${line}`);
      }
      return row;
    });
  }

  document.getElementById("btnPreview").addEventListener("click", async () => {
    const msg = document.getElementById("uploadMsg");
    msg.textContent = "";
    const f = document.getElementById("fileInput").files?.[0];
    if (!f) { msg.textContent = "CSV 파일을 선택해줘"; return; }
    const text = await f.text();
    try {
      uploadItems = parseCsv(text);
      document.getElementById("preview").textContent = JSON.stringify(uploadItems.slice(0, 200), null, 2);
      msg.textContent = `미리보기 OK (${uploadItems.length}행)`;
    } catch (e) {
      msg.textContent = "미리보기 실패: " + e.message;
    }
  });

  document.getElementById("btnApplyUpload").addEventListener("click", async () => {
    const msg = document.getElementById("uploadMsg");
    msg.textContent = "업로드 반영 중...";
    try {
      if (!uploadItems.length) throw new Error("먼저 미리보기를 해줘");

      // month_key + owner 단위로 커밋 (안전)
      const groups = {};
      uploadItems.forEach(r => {
        const k = `${r.month_key}__${r.owner}`;
        if (!groups[k]) groups[k] = { month_key: r.month_key, owner: r.owner, items: [] };
        groups[k].items.push({ category: r.category, amount: r.amount });
      });

      for (const k of Object.keys(groups)) {
        const g = groups[k];
        await callApi({
          action: "commitMonthly",
          month_key: g.month_key,
          owner: g.owner,
          source: "upload_monthly",
          items: g.items
        });
      }

      msg.textContent = `업로드 반영 완료 (${Object.keys(groups).length}그룹)`;
    } catch (e) {
      msg.textContent = "실패: " + e.message;
    }
  });

  // ================== DB (Monthly) — 기록 시트처럼 보기 ==================
  const dbCommitBtn = document.getElementById("btnDbCommit");
  const dbSourceSel = document.getElementById("dbSource");

  function syncDbFiltersFromTop() {
    document.getElementById("dbMonthKey").value = document.getElementById("monthKey").value;
    document.getElementById("dbOwner").value = document.getElementById("owner").value;
  }
  syncDbFiltersFromTop();

  document.getElementById("owner").addEventListener("change", syncDbFiltersFromTop);
  document.getElementById("monthKey").addEventListener("input", syncDbFiltersFromTop);

  function updateDbCommitAvailability() {
    const src = dbSourceSel.value;
    const msg = document.getElementById("dbMonthlyMsg");
    if (src === "ALL") {
      dbCommitBtn.disabled = true;
      msg.textContent = "source=ALL은 합산 조회용이라 저장(업데이트)할 수 없어요. ui_monthly 또는 upload_monthly를 선택하세요.";
    } else {
      dbCommitBtn.disabled = false;
      msg.textContent = "";
    }
  }
  dbSourceSel.addEventListener("change", updateDbCommitAvailability);
  updateDbCommitAvailability();

  async function readMonthlyBySource(month_key, owner, source) {
    return await callApi({ action: "readMonthly", month_key, owner, source });
  }

  document.getElementById("btnDbReload").addEventListener("click", async () => {
    const month_key = document.getElementById("dbMonthKey").value.trim();
    const owner = document.getElementById("dbOwner").value;
    const source = document.getElementById("dbSource").value;
    const msg = document.getElementById("dbMonthlyMsg");

    msg.textContent = "DB에서 불러오는 중...";
    try {
      CATEGORIES.forEach(c => state.dbMonthly[c] = "");

      if (source === "ALL") {
        const a = await readMonthlyBySource(month_key, owner, "ui_monthly");
        const b = await readMonthlyBySource(month_key, owner, "upload_monthly");

        const sums = Object.fromEntries(CATEGORIES.map(c => [c, 0]));
        for (const it of (a.items || [])) {
          if (it?.category && sums[it.category] !== undefined) sums[it.category] += Number(it.amount || 0);
        }
        for (const it of (b.items || [])) {
          if (it?.category && sums[it.category] !== undefined) sums[it.category] += Number(it.amount || 0);
        }

        for (const c of CATEGORIES) {
          if (sums[c] !== 0) state.dbMonthly[c] = String(sums[c]);
        }

        renderCategoryTable(dbMonthlyTbody, state.dbMonthly);
        msg.textContent = `DB 합산 조회 완료 (ALL) (${month_key} / ${owner})`;
        updateDbCommitAvailability();
        return;
      }

      const data = await readMonthlyBySource(month_key, owner, source);
      (data.items || []).forEach(it => {
        if (it && it.category && CATEGORIES.includes(it.category)) {
          state.dbMonthly[it.category] = (it.amount ?? "") + "";
        }
      });

      renderCategoryTable(dbMonthlyTbody, state.dbMonthly);
      msg.textContent = `DB 조회 완료 (${source}) (${month_key} / ${owner})`;
      updateDbCommitAvailability();
    } catch (e) {
      msg.textContent = "실패: " + e.message;
    }
  });

  document.getElementById("btnDbCommit").addEventListener("click", async () => {
    const month_key = document.getElementById("dbMonthKey").value.trim();
    const owner = document.getElementById("dbOwner").value;
    const source = document.getElementById("dbSource").value;
    const msg = document.getElementById("dbMonthlyMsg");

    if (source === "ALL") {
      msg.textContent = "ALL은 저장할 수 없어요. ui_monthly 또는 upload_monthly를 선택해줘.";
      return;
    }

    msg.textContent = "DB 저장(월 교체) 중...";
    try {
      const items = Object.entries(state.dbMonthly)
        .filter(([_, v]) => v !== "" && v !== null && v !== undefined)
        .map(([category, v]) => ({ category, amount: Number(v) }));

      await callApi({
        action: "commitMonthly",
        month_key,
        owner,
        source,
        items
      });

      msg.textContent = `DB 저장 완료 (${source}) (${month_key} / ${owner})`;
    } catch (e) {
      msg.textContent = "실패: " + e.message;
    }
  });
</script>
</body>
</html>


